name: "vchat-backend"

services:
  gateway:
    container_name: "${GATEWAY_CONTAINER_NAME}"
    build:
      context: ${GATEWAY_SERVICE_PATH}
    depends_on:
      - authentication
      - chat
      - real-time
      - aggregator
      - opa
    ports:
      - "${GATEWAY_HOST_PORT}:${GATEWAY_CONTAINER_PORT}"
    environment:
      - IS_DEVELOPMENT=1
      - SERVICE_PORT=${GATEWAY_CONTAINER_PORT}
      - AUTH_SERVICE_CONNECTION=${AUTH_CONTAINER_NAME}:${AUTH_CONTAINER_PORT}
      - CHAT_SERVICE_CONNECTION=${CHAT_CONTAINER_NAME}:${CHAT_CONTAINER_PORT}
      - RT_SERVICE_CONNECTION=ws://${RT_CONTAINER_NAME}:${RT_CONTAINER_PORT}
    volumes:
      - ${GATEWAY_SERVICE_PATH}/source:/app/source
    restart: always

  authentication:
    container_name: "${AUTH_CONTAINER_NAME}"
    build:
      context: ${AUTH_SERVICE_PATH}
    depends_on:
      pg-db:
        condition: service_healthy
      kafka:
        condition: service_healthy
      opa:
        condition: service_healthy
    ports:
      - "${AUTH_HOST_PORT}:${AUTH_CONTAINER_PORT}"
    environment:
      - IS_DEVELOPMENT=1
      - SECRET_KEY=${SHARED_SECRET_KEY}
      - SERVICE_ADDRESS=0.0.0.0:${AUTH_CONTAINER_PORT}
      - DATABASE_CONNECTION=postgres://${PG_DB_USER}:${PG_DB_PASSWORD}@${PG_DB_CONTAINER_NAME}:${PG_DB_CONTAINER_PORT}/${PG_DB_AUTH_NAME}
    env_file:
      - ${AUTH_SERVICE_PATH}/.env
    volumes:
      - ${AUTH_SERVICE_PATH}/source:/app/source
    restart: always

  chat:
    container_name: "${CHAT_CONTAINER_NAME}"
    build:
      context: ${CHAT_SERVICE_PATH}
    depends_on:
      pg-db:
        condition: service_healthy
      storage:
        condition: service_healthy
      kafka:
        condition: service_healthy
      opa:
        condition: service_healthy
    ports:
      - "${CHAT_HOST_PORT}:${CHAT_CONTAINER_PORT}"
    environment:
      - IS_DEVELOPMENT=1
      - SERVICE_ADDRESS=0.0.0.0:${CHAT_CONTAINER_PORT}
      - JWT_SECRET_KEY=${SHARED_SECRET_KEY}
      - JWT_ISSUER=SuperDoperAuthService
      - AUTHORIZATION_CONNECTION=http://${OPA_CONTAINER_NAME}:${OPA_CONTAINER_PORT}
      - DATABASE_CONNECTION=postgres://${PG_DB_USER}:${PG_DB_PASSWORD}@${PG_DB_CONTAINER_NAME}:${PG_DB_CONTAINER_PORT}/${PG_DB_CHAT_NAME}
    volumes:
      - ${CHAT_SERVICE_PATH}/source:/app/source
    restart: always

  real-time:
    container_name: "${RT_CONTAINER_NAME}"
    build:
      context: ${RT_SERVICE_PATH}
    depends_on:
      kafka:
        condition: service_healthy
      opa:
        condition: service_healthy
    ports:
      - "${RT_HOST_PORT}:${RT_CONTAINER_PORT}"
    environment:
      - IS_DEVELOPMENT=1
      - NAME=${RT_CONTAINER_NAME}
      - SERVICE_PORT=${RT_CONTAINER_PORT}
      - ACCEPTED_ORIGIN=${ACCEPTED_ORIGIN}
      - JWT_SECRET_KEY=${SHARED_SECRET_KEY}
      - JWT_ISSUER=SuperDoperAuthService
      - AUTHORIZATION_CONNECTION=http://${OPA_CONTAINER_NAME}:${OPA_CONTAINER_PORT}
      - KAFKA_GROUP_ID=${RT_GROUP_ID}
      - KAFKA_CLIENT_ID=${RT_CONTAINER_NAME}
      - KAFKA_BROKERS=${KAFKA_CONTAINER_NAME}:${KAFKA_CONTAINER_PORT}
    volumes:
      - ${RT_SERVICE_PATH}/source:/app/source
    restart: always

  aggregator:
    container_name: "${AGGREGATOR_CONTAINER_NAME}"
    build:
      context: ${AGGREGATOR_SERVICE_PATH}
    depends_on:
      mongo-db:
        condition: service_healthy
      kafka:
        condition: service_healthy
      opa:
        condition: service_healthy
    ports:
      - "${AGGREGATOR_HOST_PORT}:${AGGREGATOR_CONTAINER_PORT}"
    environment:
      - IS_DEVELOPMENT=1
      - SERVICE_PORT=${AGGREGATOR_CONTAINER_PORT}
      - MONGODB_CONNECTION=mongodb://${MONGO_DB_USER}:${MONGO_DB_PASSWORD}@${MONGO_DB_CONTAINER_NAME}:${MONGO_DB_CONTAINER_PORT}
      - KAFKA_GROUP_ID=${AGGREGATOR_GROUP_ID}
      - KAFKA_CLIENT_ID=${AGGREGATOR_CONTAINER_NAME}
      - KAFKA_BROKERS=${KAFKA_CONTAINER_NAME}:${KAFKA_CONTAINER_PORT}
    volumes:
      - ${AGGREGATOR_SERVICE_PATH}/source:/app/source
  
  pg-db:
    container_name: "${PG_DB_CONTAINER_NAME}"
    image: postgres:16.3-alpine
    environment:
      - POSTGRES_USER=${PG_DB_USER}
      - POSTGRES_PASSWORD=${PG_DB_PASSWORD}
      - POSTGRES_DB=${PG_DB_DEFAULT_NAME}
      - MULTIPLE_DATABASES=${PG_DB_AUTH_NAME},${PG_DB_CHAT_NAME}
    ports:
      - "${PG_DB_HOST_PORT}:${PG_DB_CONTAINER_PORT}"
    volumes:
      # - ${STORAGE_SERVICE_PATH}/data:/var/lib/postgresql/data
      - ${PG_DB_CONFIG_FILE}:/docker-entrypoint-initdb.d/create-multiple-databases.sh
    command: [ "postgres", "-c", "wal_level=logical" ]
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${PG_DB_USER} -d ${PG_DB_DEFAULT_NAME}"]
      interval: 5s
      timeout: 5s
      retries: 5

  mongo-db:
    container_name: "${MONGO_DB_CONTAINER_NAME}"
    image: mongo:7.0.11
    ports:
      - "${MONGO_DB_HOST_PORT}:${MONGO_DB_CONTAINER_PORT}"
    environment:
      - MONGO_INITDB_ROOT_USERNAME=${MONGO_DB_USER}
      - MONGO_INITDB_ROOT_PASSWORD=${MONGO_DB_PASSWORD}
    # volumes:
    #   - ${MONGO_DB_SERVICE_PATH}/data:/data/db
    healthcheck:
      test: echo 'db.runCommand("ping").ok' | mongosh localhost:27017/test --quiet
      interval: 5s
      timeout: 5s
      retries: 5

  mongo-ui:
    container_name: "${MONGO_UI_CONTAINER_NAME}"
    image: mongo-express:1.0.2-20-alpine3.19
    ports:
      - "${MONGO_UI_HOST_PORT}:${MONGO_UI_CONTAINER_PORT}"
    environment:
      - ME_CONFIG_BASICAUTH=false
      - ME_CONFIG_MONGODB_URL=mongodb://${MONGO_DB_USER}:${MONGO_DB_PASSWORD}@${MONGO_DB_CONTAINER_NAME}:${MONGO_DB_CONTAINER_PORT}
    depends_on:
      mongo-db:
        condition: service_healthy

  storage:
    container_name: "${STORAGE_CONTAINER_NAME}"
    image: bitnami/minio:2024.5.10
    ports:
      - "${STORAGE_HOST_DATA_PORT}:${STORAGE_CONTAINER_DATA_PORT}"
      - "${STORAGE_HOST_CONSOLE_PORT}:${STORAGE_CONTAINER_CONSOLE_PORT}"
    environment:
      - MINIO_ROOT_USER=${STORAGE_USER}
      - MINIO_ROOT_PASSWORD=${STORAGE_PASSWORD}
      - MINIO_API_PORT_NUMBER=${STORAGE_CONTAINER_DATA_PORT}
      - MINIO_CONSOLE_PORT_NUMBER=${STORAGE_CONTAINER_CONSOLE_PORT}
      - MINIO_DEFAULT_BUCKETS=${STORAGE_CHAT_BUCKET}:public
    # volumes:
    #   - "${STORAGE_SERVICE_PATH}/files:/bitnami/minio/data"
    healthcheck:
      test: ["CMD-SHELL", "curl -f http://localhost:${STORAGE_CONTAINER_DATA_PORT}/minio/health/live || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3

  debezium:
    container_name: "${DEBEZIUM_CONTAINER_NAME}"
    image: debezium/connect:2.7
    depends_on:
      kafka:
        condition: service_healthy
      pg-db:
        condition: service_healthy
    ports:
      - "${DEBEZIUM_HOST_PORT}:${DEBEZIUM_CONTAINER_PORT}"
    environment:
      - BOOTSTRAP_SERVERS=${KAFKA_CONTAINER_NAME}:${KAFKA_CONTAINER_PORT}
      - GROUP_ID=${DEBEZIUM_GROUP_ID}
      - CONFIG_STORAGE_TOPIC=${DEBEZIUM_CONFIG_TOPIC}
      - OFFSET_STORAGE_TOPIC=${DEBEZIUM_OFFSET_TOPIC}
      - STATUS_STORAGE_TOPIC=${DEBEZIUM_STATUS_TOPIC}
    healthcheck:
      test: ["CMD-SHELL", "curl -f http://localhost:${DEBEZIUM_CONTAINER_PORT}/connectors || exit 1"]
      interval: 10s
      timeout: 5s
      retries: 5

  debezium-ui:
    image: debezium/debezium-ui:2.5
    container_name: ${DEBEZIUM_UI_CONTAINER_NAME}
    depends_on:
      debezium:
        condition: service_healthy
    ports:
      - "${DEBEZIUM_UI_HOST_PORT}:${DEBEZIUM_UI_CONTAINER_PORT}"
    environment:
      KAFKA_CONNECT_URIS: http://${DEBEZIUM_CONTAINER_NAME}:${DEBEZIUM_CONTAINER_PORT}
    restart: always

  debezium-init:
    container_name: ${DEBEZIUM_INIT_CONTAINER_NAME}
    build:
      context: ${DEBEZIUM_CONFIG_FOLDER}
    depends_on:
      debezium:
        condition: service_healthy
    environment:
      - DEBEZIUM_CONNECTION=${DEBEZIUM_CONTAINER_NAME}:${DEBEZIUM_CONTAINER_PORT}
      - DB_HOST=${PG_DB_CONTAINER_NAME}
      - DB_PORT=${PG_DB_CONTAINER_PORT}
      - DB_AUTH_NAME=${PG_DB_AUTH_NAME}
      - DB_CHAT_NAME=${PG_DB_CHAT_NAME}
      - DB_USER=${PG_DB_USER}
      - DB_PASSWORD=${PG_DB_PASSWORD}
  
  kafka:
    container_name: "${KAFKA_CONTAINER_NAME}"
    image: bitnami/kafka:3.7
    ports:
      - "${KAFKA_HOST_PORT}:${KAFKA_CONTAINER_EXTERNAL_PORT}"
    environment:
      # KRaft settings
      - KAFKA_CFG_NODE_ID=0
      - KAFKA_CFG_PROCESS_ROLES=controller,broker
      - KAFKA_CFG_CONTROLLER_QUORUM_VOTERS=0@kafka:${KAFKA_CONTAINER_CONTROLLER_PORT}
      # Listeners
      - KAFKA_CFG_LISTENERS=PLAINTEXT://:${KAFKA_CONTAINER_PORT},CONTROLLER://:${KAFKA_CONTAINER_CONTROLLER_PORT},EXTERNAL://:${KAFKA_CONTAINER_EXTERNAL_PORT}
      - KAFKA_CFG_ADVERTISED_LISTENERS=PLAINTEXT://kafka:${KAFKA_CONTAINER_PORT},EXTERNAL://localhost:${KAFKA_CONTAINER_EXTERNAL_PORT}
      - KAFKA_CFG_LISTENER_SECURITY_PROTOCOL_MAP=CONTROLLER:PLAINTEXT,EXTERNAL:PLAINTEXT,PLAINTEXT:PLAINTEXT
      # Others
      - KAFKA_CFG_CONTROLLER_LISTENER_NAMES=CONTROLLER
      - KAFKA_CFG_INTER_BROKER_LISTENER_NAME=PLAINTEXT
      - KAFKA_CFG_AUTO_CREATE_TOPICS_ENABLE=true
    # volumes:
      # - ${KAFKA_SERVICE_PATH}:/bitnami/kafka
    healthcheck:
      test: kafka-topics.sh --list --bootstrap-server localhost:${KAFKA_CONTAINER_PORT} || exit 1
      interval: 1s
      timeout: 60s
      retries: 60

  kafka-ui:
    container_name: ${KAFKA_UI_CONTAINER_NAME}
    image: provectuslabs/kafka-ui:v0.7.2
    ports:
      - "${KAFKA_UI_HOST_PORT}:${KAFKA_UI_CONTAINER_PORT}"
    environment:
      - DYNAMIC_CONFIG_ENABLED=true
    depends_on:
      kafka:
        condition: service_healthy

  opa:
    container_name: "${OPA_CONTAINER_NAME}"
    build:
      context: ${OPA_CONFIG_FOLDER}
    ports:
      - "${OPA_HOST_PORT}:${OPA_CONTAINER_PORT}"
    environment:
      AGGRAGATOR_CONNECTION: http://${AGGREGATOR_CONTAINER_NAME}:${AGGREGATOR_CONTAINER_PORT}
    volumes:
      - ${OPA_CONFIG_FOLDER}/policies:/policies
    healthcheck:
      test: ["CMD-SHELL", "curl -f http://0.0.0.0:${OPA_CONTAINER_PORT}/health || exit 1"]
      interval: 5s
      timeout: 5s
      retries: 3